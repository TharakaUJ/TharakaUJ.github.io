---
permalink: /testing/
title: "Testing"
author_profile: false
sidebar: false
---
<!DOCTYPE html>
<html>

<head>
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
    <script>
        AFRAME.registerComponent('adjust-on-lost', {
            schema: {
                sensitivity: { type: 'number', default: 0.005 }
            },
            init: function () {
                console.log("strt")
                const marker = document.querySelector('#marker');
                const model = document.querySelector('#model');

                if (!marker || !model) {
                    console.error('Marker or model not found.');
                    return;
                }

                this.lastKnownPosition = { x: 0, y: 0, z: 0 };
                this.lastKnownRotation = { x: 0, y: 0, z: 0 };
                this.deviceRotation = { alpha: 0, beta: 0, gamma: 0 };
                this.modelDetached = false;

                // Listen for marker visibility events
                marker.addEventListener('markerFound', () => {
                    console.log('Marker found');
                    this.lastKnownPosition = marker.object3D.position.clone();
                    this.lastKnownRotation = marker.object3D.rotation.clone();
                    this.modelDetached = false;
                    model.setAttribute('visible', 'true'); // Re-attach the model when the marker is found
                    model.parentElement = marker;
                    model.object3D.position.copy(marker.object3D.position);
                });

                marker.addEventListener('markerLost', () => {
                    console.log('Marker lost');
                    this.modelDetached = true; // Mark model as detached
                    model.setAttribute('visible', 'true'); // Keep the marker visible even when the model is detached
                    model.parentElement = null;
                });

                // Listen for device orientation
                window.addEventListener('deviceorientation', (event) => {
                    if (!modelDetached) {
                        return;
                    }

                    this.deviceRotation = {
                        alpha: event.alpha || 0,
                        beta: event.beta || 0,
                        gamma: event.gamma || 0,
                    };
                });

                window.addEventListener('devicemotion', (event) => {
                    if (!modelDetached) {
                        return;
                    }
                    const accel = event.acceleration; // Linear acceleration in m/s^2
                    const deltaTime = event.interval / 1000; // Convert interval to seconds

                    if (accel) {
                        // Update velocity (v = v0 + a * t)
                        lastVelocity.x += (accel.x || 0) * deltaTime;
                        lastVelocity.y += (accel.y || 0) * deltaTime;
                        lastVelocity.z += (accel.z || 0) * deltaTime;

                        // Update position (s = s0 + v * t + 0.5 * a * t^2)
                        lastKnownPosition.x += lastVelocity.x * deltaTime + 0.5 * (accel.x || 0) * deltaTime ** 2;
                        lastKnownPosition.y += lastVelocity.y * deltaTime + 0.5 * (accel.y || 0) * deltaTime ** 2;
                        lastKnownPosition.z += lastVelocity.z * deltaTime + 0.5 * (accel.z || 0) * deltaTime ** 2;

                        console.log('Updated Position:', lastKnownPosition);
                    }
                });

                // Update model position on each frame
                this.el.sceneEl.addEventListener('tick', () => {
                    const { sensitivity } = this.data;
                    if (this.modelDetached) {

                        if (this.lastKnownPosition) {
                            // Adjust model's position based on device rotation
                            const deltaX = this.deviceRotation.gamma * sensitivity;
                            const deltaZ = this.deviceRotation.beta * sensitivity;

                            const adjustedPosition = this.lastKnownPosition.clone();
                            adjustedPosition.x += deltaX;
                            adjustedPosition.z += deltaZ;

                            model.object3D.position.copy(adjustedPosition);
                        }

                        if (this.lastKnownRotation) {
                            // Optionally adjust the rotation of the model based on device orientation
                            const rotationFactor = this.deviceRotation.alpha * sensitivity;
                            model.object3D.rotation.y = this.lastKnownRotation.y + rotationFactor;
                        }
                    } else {
                        // Re-attach the model to the marker
                        model.object3D.position.copy(marker.object3D.position);
                        model.object3D.rotation.copy(marker.object3D.rotation);
                    }

                    model.object3D.updateMatrixWorld();
                });
            }
        });
    </script>
</head>

<body>
    <a-scene adjust-on-lost embedded arjs="debugUIEnabled: false;" vr-mode-ui="enabled: false">
        <!-- Marker for initialization -->
        <a-marker id="marker" preset="custom" type="pattern" url="/assets/ar/qr-pattern.patt" smooth="true"
            preload="true" smoothCount="10" smoothTolerance="0.01" smoothThreshold="2">
            <!-- Model (will be visible even when marker is lost) -->
            <!-- <a-entity id="model" gltf-model="Pathfinder_2k.glb" scale="1 1 1" position="0 0 0">
            </a-entity> -->
        </a-marker>

        <a-entity id="model" gltf-model="/assets/ar/Pathfinder_2k.glb" scale="1 1 1" position="0 0 0" visible="false">
        </a-entity>
        <a-entity camera></a-entity>
    </a-scene>
</body>


</html>